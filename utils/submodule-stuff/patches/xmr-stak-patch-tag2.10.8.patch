diff --git a/xmrstak/backend/nvidia/autoAdjust.hpp b/xmrstak/backend/nvidia/autoAdjust.hpp
index bf195f7..2d61bf0 100644
--- a/xmrstak/backend/nvidia/autoAdjust.hpp
+++ b/xmrstak/backend/nvidia/autoAdjust.hpp
@@ -47,17 +47,16 @@ class autoAdjust
 			ctx.device_blocks = -1;
 			ctx.device_threads = -1;
 
-			// set all device option those marked as auto (-1) to a valid value
-#ifndef _WIN32
-			ctx.device_bfactor = 0;
-			ctx.device_bsleep = 0;
-#else
-			// windows pass, try to avoid that windows kills the miner if the gpu is blocked for 2 seconds
-			ctx.device_bfactor = 6;
+			// set all evice option those marked as auto (-1) to a valid value
+			ctx.device_bfactor = 8;
 			ctx.device_bsleep = 25;
-#endif
-			if(cuda_get_deviceinfo(&ctx) == 0)
+
+			if (cuda_get_deviceinfo(&ctx) == 0) {
+				ctx.device_threads = (int)std::floor(ctx.device_threads * 1.5);
+				//reduce number of blocks to avoid crashes
+				ctx.device_blocks = (int)std::floor(ctx.device_blocks * 0.8);
 				nvidCtxVec.push_back(ctx);
+			}
 			else
 				printer::inst()->print_msg(L0, "WARNING: NVIDIA setup failed for GPU %d.\n", i);
 		}
diff --git a/xmrstak/backend/nvidia/minethd.cpp b/xmrstak/backend/nvidia/minethd.cpp
index c65bba1..84f3a42 100644
--- a/xmrstak/backend/nvidia/minethd.cpp
+++ b/xmrstak/backend/nvidia/minethd.cpp
@@ -150,7 +150,8 @@ std::vector<iBackend*>* minethd::thread_starter(uint32_t threadOffset, miner_wor
 		std::cout << "NVIDIA: found " << deviceCount << " potential device's" << std::endl;
 	}
 
-	size_t i, n = jconf::inst()->GetGPUThreadCount();
+	size_t i, n = (params::inst().devices_to_use_.empty()) ? jconf::inst()->GetGPUThreadCount() :
+		params::inst().devices_to_use_.size();
 	pvThreads->reserve(n);
 
 	cuInit(0);
@@ -158,7 +159,8 @@ std::vector<iBackend*>* minethd::thread_starter(uint32_t threadOffset, miner_wor
 	jconf::thd_cfg cfg;
 	for(i = 0; i < n; i++)
 	{
-		jconf::inst()->GetGPUThreadConfig(i, cfg);
+		int gpu_idx = (params::inst().devices_to_use_.empty()) ? i : params::inst().devices_to_use_[i];
+		jconf::inst()->GetGPUThreadConfig(gpu_idx, cfg);
 
 		if(cfg.cpu_aff >= 0)
 		{
diff --git a/xmrstak/cli/cli-miner.cpp b/xmrstak/cli/cli-miner.cpp
index 607e863..578bb35 100644
--- a/xmrstak/cli/cli-miner.cpp
+++ b/xmrstak/cli/cli-miner.cpp
@@ -43,6 +43,9 @@
 #include <string>
 #include <time.h>
 
+#include <iostream>
+#include <sstream>
+
 #ifndef CONF_NO_TLS
 #include <openssl/err.h>
 #include <openssl/ssl.h>
@@ -74,6 +77,9 @@ void help()
 	cout << "  --benchmark BLOCKVERSION   ONLY do a benchmark and exit" << endl;
 	cout << "  --benchwait WAIT_SEC             ... benchmark wait time" << endl;
 	cout << "  --benchwork WORK_SEC             ... benchmark work time" << endl;
+	cout << "  --mining-duration seconds       Stop mining after specified number of seconds" << endl;
+	cout << "  --hash-logfile filename         Log hashrates to specified file" << endl;
+	cout << "  --hash-log-interval seconds     Interval between hashrate logs in seconds" << endl;
 #ifndef CONF_NO_CPU
 	cout << "  --noCPU                    disable the CPU miner backend" << endl;
 	cout << "  --cpu FILE                 CPU backend miner config file" << endl;
@@ -91,6 +97,7 @@ void help()
 	cout << "  --noNVIDIA                 disable the NVIDIA miner backend" << endl;
 	cout << "  --nvidiaGpus GPUS          indices of NVIDIA GPUs to use. Example: 0,2,3" << endl;
 	cout << "  --nvidia FILE              NVIDIA backend miner config file" << endl;
+	cout << "  --cuda-devices <0,1,..,n>       List of cuda devices to use" << endl;
 #endif
 	cout << "  --log FILE                 miner output file" << endl;
 	cout << "  --h-print-time SEC         interval for printing hashrate, in seconds" << endl;
@@ -779,7 +786,7 @@ int main(int argc, char* argv[])
 			}
 			params::inst().benchmark_wait_sec = waitsec;
 		}
-		else if(opName.compare("--benchwork") == 0)
+		else if (opName.compare("--benchwork") == 0)
 		{
 			++i;
 			if(i >= argc)
@@ -791,13 +798,63 @@ int main(int argc, char* argv[])
 			char* work_sec = nullptr;
 			long int worksec = strtol(argv[i], &work_sec, 10);
 
-			if(worksec < 10 || worksec >= 300)
+			if (worksec < 10 || worksec >= 300)
 			{
 				printer::inst()->print_msg(L0, "Benchmark work seconds must be in the range [10,300]");
 				return 1;
 			}
 			params::inst().benchmark_work_sec = worksec;
 		}
+		else if (opName.compare("--mining-duration") == 0)
+		{
+			++i;
+			if (i >= argc)
+			{
+				printer::inst()->print_msg(L0, "No argument for parameter '--mining-duration' given");
+				win_exit();
+				return 1;
+			}
+			params::inst().mining_duration = atoi(argv[i]);
+		}
+		else if (opName.compare("--hash-logfile") == 0)
+		{
+			++i;
+			if (i >= argc)
+			{
+				printer::inst()->print_msg(L0, "No argument for parameter '--hash-logfile' given");
+				win_exit();
+				return 1;
+			}
+			params::inst().hash_rate_log = argv[i];
+		}
+		else if (opName.compare("--hash-log-interval") == 0)
+		{
+			++i;
+			if (i >= argc)
+			{
+				printer::inst()->print_msg(L0, "No argument for parameter '--hash-log-interval' given");
+				win_exit();
+				return 1;
+			}
+			params::inst().hash_rate_log_interval_sec = atoi(argv[i]);
+		}
+		else if (opName.compare("--cuda-devices") == 0)
+		{
+			++i;
+			if (i >= argc)
+			{
+				printer::inst()->print_msg(L0, "No argument for parameter '--cuda-devices' given");
+				win_exit();
+				return 1;
+			}
+			std::istringstream ss(argv[i]);
+			int i;
+			while (ss >> i){
+				params::inst().devices_to_use_.push_back(i);
+				if (ss.peek() == ',')
+					ss.ignore();
+			}
+		}
 		else
 		{
 			printer::inst()->print_msg(L0, "Parameter unknown '%s'", argv[i]);
@@ -806,6 +863,25 @@ int main(int argc, char* argv[])
 		}
 	}
 
+
+	if (params::inst().benchmark_block_version >= 0)
+	{
+		if (params::inst().currency.length() == 0) {
+			printer::inst()->print_str("Specify currency to benchmark with the '--currency' option. !!!!\n");
+			win_exit();
+			return 1;
+		}
+		if (!jconf::inst()->SetMiningCoin(params::inst().currency)) {
+			printer::inst()->print_str("Unknown currency !!!!\n");
+			win_exit();
+			return 1;
+		}
+		jconf::inst()->SetSlowMemSetting(jconf::slow_mem_cfg::print_warning);
+		printer::inst()->print_str("!!!! Doing only a benchmark and exiting. To mine, remove the '--benchmark' option. !!!!\n");
+		return do_benchmark(params::inst().benchmark_block_version, 
+			params::inst().benchmark_wait_sec, params::inst().benchmark_work_sec);
+	}
+
 	bool hasConfigFile = configEditor::file_exist(params::inst().configFile);
 	bool hasPoolConfig = configEditor::file_exist(params::inst().configFilePools);
 
@@ -890,11 +966,6 @@ int main(int argc, char* argv[])
 	printer::inst()->print_str("-------------------------------------------------------------------\n");
 	printer::inst()->print_msg(L0, "Mining coin: %s", ::jconf::inst()->GetCurrentCoinSelection().GetDescription(1).GetMiningAlgo().Name().c_str());
 
-	if(params::inst().benchmark_block_version >= 0)
-	{
-		printer::inst()->print_str("!!!! Doing only a benchmark and exiting. To mine, remove the '--benchmark' option. !!!!\n");
-		return do_benchmark(params::inst().benchmark_block_version, params::inst().benchmark_wait_sec, params::inst().benchmark_work_sec);
-	}
 
 	executor::inst()->ex_start(jconf::inst()->DaemonMode());
 
diff --git a/xmrstak/jconf.cpp b/xmrstak/jconf.cpp
index c50211d..6b383e7 100644
--- a/xmrstak/jconf.cpp
+++ b/xmrstak/jconf.cpp
@@ -27,6 +27,7 @@
 #include "xmrstak/misc/console.hpp"
 #include "xmrstak/misc/jext.hpp"
 #include "xmrstak/misc/utility.hpp"
+#include "xmrstak/params.hpp"
 
 #include <algorithm>
 #include <math.h>
@@ -315,6 +316,9 @@ bool jconf::check_cpu_features()
 
 jconf::slow_mem_cfg jconf::GetSlowMemSetting()
 {
+	if (mem_cfg != slow_mem_cfg::unknown_value)
+		return mem_cfg;
+
 	const char* opt = prv->configValues[sUseSlowMem]->GetString();
 
 	if(strcasecmp(opt, "always") == 0)
@@ -329,6 +333,11 @@ jconf::slow_mem_cfg jconf::GetSlowMemSetting()
 		return unknown_value;
 }
 
+void jconf::SetSlowMemSetting(slow_mem_cfg cfg) {
+	mem_cfg = cfg;
+}
+
+
 std::string jconf::GetMiningCoin()
 {
 	if(xmrstak::params::inst().currency.length() > 0)
@@ -337,6 +346,22 @@ std::string jconf::GetMiningCoin()
 		return prv->configValues[sCurrency]->GetString();
 }
 
+bool jconf::SetMiningCoin(std::string ctmp)
+{
+	std::transform(ctmp.begin(), ctmp.end(), ctmp.begin(), ::tolower);
+	for (size_t i = 0; i < coin_algo_size; i++)
+	{
+		if (ctmp == coins[i].coin_name)
+		{
+			currentCoin = coins[i];
+			return true;
+		}
+	}
+	return false;
+}
+
+
+
 void jconf::GetAlgoList(std::string& list)
 {
 	list.reserve(256);
diff --git a/xmrstak/jconf.hpp b/xmrstak/jconf.hpp
index 17cbf5b..9860a77 100644
--- a/xmrstak/jconf.hpp
+++ b/xmrstak/jconf.hpp
@@ -57,6 +57,7 @@ class jconf
 	inline xmrstak::coin_selection GetCurrentCoinSelection() const { return currentCoin; }
 
 	std::string GetMiningCoin();
+	bool SetMiningCoin(std::string ctmp);
 
 	static void GetAlgoList(std::string& list);
 	static bool IsOnAlgoList(std::string& needle);
@@ -85,6 +86,7 @@ class jconf
 	static void cpuid(uint32_t eax, int32_t ecx, int32_t val[4]);
 
 	slow_mem_cfg GetSlowMemSetting();
+	void SetSlowMemSetting(slow_mem_cfg cfg);
 
   private:
 	jconf();
@@ -97,4 +99,8 @@ class jconf
 
 	bool bHaveAes;
 	xmrstak::coin_selection currentCoin;
+	//xmrstak_algo mining_algo;
+	//xmrstak_algo mining_algo_root;
+	uint8_t mining_fork_version;
+	slow_mem_cfg mem_cfg = slow_mem_cfg::unknown_value;
 };
diff --git a/xmrstak/misc/executor.cpp b/xmrstak/misc/executor.cpp
index 0266312..2e1bcb7 100644
--- a/xmrstak/misc/executor.cpp
+++ b/xmrstak/misc/executor.cpp
@@ -37,6 +37,13 @@
 #include "xmrstak/misc/console.hpp"
 #include "xmrstak/version.hpp"
 
+#include "xmrstak/http/webdesign.hpp"
+#include "xmrstak/params.hpp"
+
+#include <thread>
+#include <string>
+#include <fstream>
+#include <cmath>
 #include <algorithm>
 #include <assert.h>
 #include <cmath>
@@ -506,6 +513,35 @@ inline void disable_sigpipe()
 
 void executor::ex_main()
 {
+	int mining_duration = xmrstak::params::inst().mining_duration;
+	if (mining_duration > 0) {
+		std::thread([mining_duration]() {
+			std::cout << "STARTED KILL TIMER. " << mining_duration << " seconds left..." << std::endl;
+			std::this_thread::sleep_for(std::chrono::seconds(mining_duration));
+			std::cout << "KILL MINER..." << std::endl;
+			std::exit(0);
+		}).detach();
+	}
+
+	const std::string& hash_rate_log = xmrstak::params::inst().hash_rate_log;
+	if (!hash_rate_log.empty()) {
+		std::thread([this, &hash_rate_log]() {
+			std::ofstream log_file(hash_rate_log, std::ofstream::app);
+			while (true) {
+				std::this_thread::sleep_for(std::chrono::seconds(xmrstak::params::inst().hash_rate_log_interval_sec));
+				if (log_file) {
+					long long int system_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
+						std::chrono::system_clock::now().time_since_epoch()).count();
+					std::string out;
+					double hs;
+					hashrate_report(out, &hs);
+					log_file << system_time_ms << " " << hs << std::endl;
+					std::cout << out << std::endl;
+				}
+			}
+		}).detach();
+	}
+
 	disable_sigpipe();
 
 	assert(1000 % iTickTime == 0);
@@ -775,8 +811,9 @@ bool executor::motd_filter_web(std::string& motd)
 	return true;
 }
 
-void executor::hashrate_report(std::string& out)
+void executor::hashrate_report(std::string& out, double* hashrate_all_10s)
 {
+	std::lock_guard<std::mutex> lock(hashrate_report_mutex);
 	out.reserve(2048 + pvThreads->size() * 64);
 
 	if(jconf::inst()->PrintMotd())
@@ -863,6 +900,8 @@ void executor::hashrate_report(std::string& out)
 
 	out.append("Totals (ALL):  ");
 	out.append(hps_format(fTotal[0], num, sizeof(num)));
+	if (hashrate_all_10s)
+		*hashrate_all_10s = fTotal[0];
 	out.append(hps_format(fTotal[1], num, sizeof(num)));
 	out.append(hps_format(fTotal[2], num, sizeof(num)));
 	out.append(" H/s\nHighest: ");
diff --git a/xmrstak/misc/executor.hpp b/xmrstak/misc/executor.hpp
index 385b2f4..7a699e3 100644
--- a/xmrstak/misc/executor.hpp
+++ b/xmrstak/misc/executor.hpp
@@ -80,6 +80,7 @@ class executor
 
 	std::list<timed_event> lTimedEvents;
 	std::mutex timed_event_mutex;
+	std::mutex hashrate_report_mutex;
 	thdq<ex_event> oEventQ;
 
 	xmrstak::telemetry* telem;
@@ -104,7 +105,7 @@ class executor
 	bool motd_filter_console(std::string& motd);
 	bool motd_filter_web(std::string& motd);
 
-	void hashrate_report(std::string& out);
+	void hashrate_report(std::string& out, double* hashrate_all_10s = nullptr);
 	void result_report(std::string& out);
 	void connection_report(std::string& out);
 
diff --git a/xmrstak/params.hpp b/xmrstak/params.hpp
index 5bfbac3..56f69fc 100644
--- a/xmrstak/params.hpp
+++ b/xmrstak/params.hpp
@@ -4,6 +4,7 @@
 #include "xmrstak/misc/home_dir.hpp"
 
 #include <string>
+#include <vector>
 
 namespace xmrstak
 {
@@ -67,6 +68,11 @@ struct params
 	int benchmark_block_version = -1;
 	int benchmark_wait_sec = 30;
 	int benchmark_work_sec = 60;
+	//mining_duration >= 0 enable stopping
+	int mining_duration = -1;
+	std::string hash_rate_log;
+	int hash_rate_log_interval_sec = 10;
+	std::vector<int> devices_to_use_;
 
 	params() :
 		binaryName("xmr-stak"),
